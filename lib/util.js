// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.epsilon = 0.0001;

  this.Color = (function() {

    function Color(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.mulNumber = __bind(this.mulNumber, this);

      this.mulColor = __bind(this.mulColor, this);

      this.sub = __bind(this.sub, this);

      this.add = __bind(this.add, this);

    }

    Color.prototype.add = function(c) {
      return new Color(this.r + c.r, this.g + c.g, this.b + c.b);
    };

    Color.prototype.sub = function(c) {
      return new Color(this.r - c.r, this.g - c.g, this.b - c.b);
    };

    Color.prototype.mulColor = function(c) {
      return new Color(this.r * c.r, this.g * c.g, this.b * c.b);
    };

    Color.prototype.mulNumber = function(d) {
      return new Color(this.r * d, this.g * d, this.b * d);
    };

    return Color;

  })();

  this.Ray = (function() {

    function Ray(o, d) {
      this.o = o;
      this.d = d;
      this.tOf = __bind(this.tOf, this);

      this.at = __bind(this.at, this);

    }

    Ray.prototype.at = function(t) {
      return this.o.add(this.d.mul(t));
    };

    Ray.prototype.tOf = function(p) {
      return this.o.sub(p).magnitude;
    };

    return Ray;

  })();

  this.World = (function() {

    function World(backgroundColor, elements, lights, ambient, indexOfRefraction) {
      this.backgroundColor = backgroundColor;
      this.elements = elements;
      this.lights = lights;
      this.ambient = ambient;
      this.indexOfRefraction = indexOfRefraction;
      this.hit = __bind(this.hit, this);

    }

    World.prototype.hit = function(ray) {
      var element, h, temp, _i, _len, _ref;
      temp = null;
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        h = element.hit(ray);
        if (temp === null) {
          temp = h;
        }
        if (temp !== null && h !== null && temp.t > h.t) {
          temp = h;
        }
      }
      return temp;
    };

    return World;

  })();

  this.Hit = (function() {

    function Hit(t, ray, geo, normal) {
      this.t = t;
      this.ray = ray;
      this.geo = geo;
      this.normal = normal;
    }

    return Hit;

  })();

  this.Tracer = (function() {

    Tracer.maxDepth = 6;

    function Tracer(world) {
      this.world = world;
      this.colorFor = __bind(this.colorFor, this);

      this.recursionCounter = this.maxDepth;
    }

    Tracer.prototype.colorFor = function(ray) {
      var color, hit;
      this.recursionCounter--;
      if (this.recursionCounter > 0) {
        hit = this.world.hit(ray);
        if (hit !== null) {
          color = hit.geo.material.colorFor(hit, this.world, this);
          this.recursionCounter = maxDepth;
          color;

        }
      }
      this.recursionCounter = this.maxDepth;
      return this.world.backgroundColor;
    };

    return Tracer;

  })();

  this.Node = (function(_super) {

    __extends(Node, _super);

    function Node(transformation, geometries, material) {
      this.transformation = transformation;
      this.geometries = geometries;
      this.hit = __bind(this.hit, this);

      Node.__super__.constructor.call(this, material);
    }

    Node.prototype.hit = function(ray) {
      var element, h, r, temp, _i, _len, _ref;
      r = new Ray(this.transformation.i.x(ray.o), this.transformation.i.x(ray.d));
      temp = null;
      _ref = this.geometries;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        h = element.hit(r);
        if (temp === null) {
          temp = h;
        }
        if (temp !== null && h !== null && temp.t > h.t) {
          temp = h;
        }
      }
      if (temp !== null) {
        return new Hit(temp.t, ray, temp.geo, this.transformation.i.transpond().cross(new Vector3(temp.normal.x, temp.normal.y, temp.normal.z)).asNormal());
      }
    };

    return Node;

  })(Geometry);

  this.Transform = (function() {

    function Transform(m, i) {
      this.m = m;
      this.i = i;
    }

    Transform.Translation = function(x, y, z) {
      return new Transform(new Mat4x4(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), new Mat4x4(1, 0, 0, -x, 0, 1, 0, -y, 0, 0, 1, -z, 0, 0, 0, 1));
    };

    Transform.Scaling = function(sx, sy, sz) {
      return new Transform(new Mat4x4(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1), new Mat4x4(1 / sx, 0, 0, 0, 0, 1 / sy, 0, 0, 0, 0, 1 / sz, 0, 0, 0, 0, 1));
    };

    Transform.XRotation = function(angle) {
      return new Transform(new Mat4x4(1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1), new Mat4x4(1, 0, 0, 0, 0, Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1));
    };

    Transform.YRotation = function(angle) {
      return new Transform(new Mat4x4(Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1), new Mat4x4(Math.cos(angle), 0, -Math.sin(angle), 0, 0, 1, 0, 0, Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1));
    };

    Transform.ZRotation = function(angle) {
      return new Transform(new Mat4x4(Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), new Mat4x4(Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
    };

    Transform.prototype.translate = function(x, y, z) {
      return new Transform(this.m.xMat(new Mat4x4(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1)), this.i.xMat(new Mat4x4(1, 0, 0, -x, 0, 1, 0, -y, 0, 0, 1, -z, 0, 0, 0, 1)));
    };

    Transform.prototype.scale = function(sx, sy, sz) {
      return new Transform(this.m.xMat(new Mat4x4(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1)), this.i.xMat(new Mat4x4(1 / sx, 0, 0, 0, 0, 1 / sy, 0, 0, 0, 0, 1 / sz, 0, 0, 0, 0, 1)));
    };

    Transform.prototype.xRotate = function(angle) {
      return new Transform(this.m.xMat(new Mat4x4(1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1)), this.i.xMat(new Mat4x4(1, 0, 0, 0, 0, Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1)));
    };

    Transform.prototype.yRotate = function(angle) {
      return new Transform(this.m.xMat(new Mat4x4(Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1)), this.i.xMat(new Mat4x4(Math.cos(angle), 0, -Math.sin(angle), 0, 0, 1, 0, 0, Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1)));
    };

    Transform.prototype.zRotate = function(angle) {
      return new Transform(this.m.xMat(new Mat4x4(Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)), this.i.xMat(new Mat4x4(Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)));
    };

    return Transform;

  })();

}).call(this);
