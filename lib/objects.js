// Generated by CoffeeScript 1.5.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Geometry = (function() {

    function Geometry(material) {
      this.material = material;
    }

    return Geometry;

  })();

  this.Plane = (function(_super) {

    __extends(Plane, _super);

    function Plane(material) {
      this.hit = __bind(this.hit, this);      Plane.__super__.constructor.call(this, material);
      this.a = new Point3(0, 0, 0);
      this.n = new Normal3(0, 1, 0);
    }

    Plane.prototype.hit = function(ray) {
      var t;
      t = this.a.subPoint(ray.o).dot(this.n) / ray.d.dot(this.n);
      if (t > epsilon(new Hit(t, ray, this, this.n))) {

      } else {
        return null;
      }
    };

    return Plane;

  })(Geometry);

  this.AxisAlignedBox = (function(_super) {

    __extends(AxisAlignedBox, _super);

    function AxisAlignedBox(material) {
      this.hit = __bind(this.hit, this);      AxisAlignedBox.__super__.constructor.call(this, material);
      this.lbf = new Point3(-0.5, -0.5, -0.5);
      this.run = new Point3(0.5, 0.5, 0.5);
    }

    AxisAlignedBox.prototype.hit = function(ray) {
      var a, b, c, face_in, face_out, t0, t1, tx_max, tx_min, ty_max, ty_min, tz_max, tz_min, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      a = 1.0 / ray.d.x;
      if (a >= epsilon) {
        tx_min = (this.lbf.x - ray.o.x) * a;
        tx_max = (this.run.x - ray.o.x) * a;
      } else {
        tx_max = (this.lbf.x - ray.o.x) * a;
        tx_min = (this.run.x - ray.o.x) * a;
      }
      b = 1.0 / ray.d.y;
      if (b >= epsilon) {
        ty_min = (this.lbf.y - ray.o.y) * b;
        ty_max = (this.run.y - ray.o.y) * b;
      } else {
        ty_max = (this.lbf.y - ray.o.y) * b;
        ty_min = (this.run.y - ray.o.y) * b;
      }
      c = 1.0 / ray.d.z;
      if (c >= epsilon) {
        tz_min = (this.lbf.z - ray.o.z) * c;
        tz_max = (this.run.z - ray.o.z) * c;
      } else {
        tz_max = (this.lbf.z - ray.o.z) * c;
        tz_min = (this.run.z - ray.o.z) * c;
      }
      if (tx_min > ty_min) {
        t0 = tx_min;
        face_in = (_ref = a >= 0.0) != null ? _ref : {
          0: 3
        };
      } else {
        t0 = ty_min;
        face_in = (_ref1 = b >= 0.0) != null ? _ref1 : {
          1: 4
        };
      }
      if (tz_min > t0) {
        t0 = tz_min;
        face_in = (_ref2 = c >= 0.0) != null ? _ref2 : {
          2: 5
        };
      }
      if (tx_max < ty_max) {
        t1 = tx_max;
        face_out = (_ref3 = a >= 0.0) != null ? _ref3 : {
          3: 0
        };
      } else {
        t1 = ty_max;
        face_out = (_ref4 = b >= 0.0) != null ? _ref4 : {
          4: 1
        };
      }
      if (tz_max < t1) {
        t1 = tz_max;
        face_out = (_ref5 = c >= 0.0) != null ? _ref5 : {
          5: 2
        };
      }
      if (t0 < t1 && t1 > epsilon) {
        if (t0 > epsilon) {
          return new Hit(t0, ray, this, getNormal(face_in));
        } else {
          return new Hit(t1, ray, this, getNormal(face_out));
        }
      }
      return null;
    };

    AxisAlignedBox.prototype.getNormal = function(face) {
      switch (face) {
        case 0:
          return new Normal3(-1, 0, 0);
        case 1:
          return new Normal3(0, -1, 0);
        case 2:
          return new Normal3(0, 0, -1);
        case 3:
          return new Normal3(1, 0, 0);
        case 4:
          return new Normal3(0, 1, 0);
        case 5:
          return new Normal3(0, 0, 1);
      }
      return null;
    };

    return AxisAlignedBox;

  })(Geometry);

  this.Sphere = (function(_super) {

    __extends(Sphere, _super);

    function Sphere(material) {
      this.hit = __bind(this.hit, this);      Sphere.__super__.constructor.call(this, material);
      this.c = new Point3(0, 0, 0);
      this.r = 1;
    }

    Sphere.prototype.hit = function(ray) {
      var a, b, cn, d, t;
      a = ray.d.dot(ray.d);
      b = ray.d.dot((ray.o.subPoint(this.c)).mul(2));
      cn = ray.o.subPoint(this.c).dot(ray.o.subPoint(this.c)) - (this.r * this.r);
      d = (b * b) - 4.0 * a * cn;
      t = (-b - Math.sqrt(d)) / (2.0 * a);
      if (d > epsilon) {
        if (t > epsilon) {
          return new Hit(t, ray, this, ray.o.subPoint(this.c).add(ray.d.mul(t)).mul(1.0 / this.r).asNormal());
        }
        t = (-b + Math.sqrt(d)) / (2.0 * a);
        if (t > epsilon) {
          return new Hit(t, ray, this, ray.o.subPoint(this.c).add(ray.d.mul(t)).mul(1.0 / this.r).asNormal());
        }
      }
      return null;
    };

    return Sphere;

  })(Geometry);

}).call(this);
